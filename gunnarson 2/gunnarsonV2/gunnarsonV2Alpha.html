<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Gunnarson V2 Alpha</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script><!--J Query-->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js'></script><!--GL Matrix-->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script> <!--Cannon.js-->
        <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }
        
        a {
            color: #ff0;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        button {
            cursor: pointer;
            text-transform: uppercase;
        }
        
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            z-index: 1; /* TODO Solve this in HTML */
        }
        
        a, button, input, select {
            pointer-events: auto;
        }
        
        .lil-gui {
            z-index: 2 !important; /* TODO Solve this in HTML */
        }
        
        @media all and ( max-width: 640px ) {
            .lil-gui.root { 
                right: auto;
                top: auto;
                max-height: 50%;
                max-width: 80%;
                bottom: 0;
                left: 0;
            }
        }
        
        #overlay {
            position: absolute;
            font-size: 16px;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0,0,0,0.7);
        }
        
            #overlay button {
                background: transparent;
                border: 0;
                border: 1px solid rgb(255, 255, 255);
                border-radius: 4px;
                color: #ffffff;
                padding: 12px 18px;
                text-transform: uppercase;
                cursor: pointer;
            }
        
        #notSupported {
            width: 50%;
            margin: auto;
            background-color: #f00;
            margin-top: 20px;
            padding: 10px;
        }
        </style>
	</head>
	<body>

		<script type="importmap">
            {
                "imports": {
                  "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.172.0/three.module.js",
                  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/",
                }
            }
        </script>
   
        <script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>

		<script type="module">

			import * as THREE from 'three';
			import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, plat1, prototype5x5G;


            function resize( object, scaleX, scaleY, scaleZ, updateUV )
            {
                object.scale.set( 5*scaleX, 5*scaleY, 5*scaleZ );
            
                if( updateUV )
                {
                    var pos = object.geometry.getAttribute( 'position' ),
                        uv = object.geometry.getAttribute( 'uv' );

                    for( var i=0; i<pos.count; i++ )
                    {
                        var x = scaleX * (-pos.getX(i)+0.5),
                            y = scaleY * (-pos.getY(i)+0.5),
                            z = scaleZ * (-pos.getZ(i)+0.5);

                        if( i<8 ) uv.setXY( i, z, y );
                        else if( i<16 ) uv.setXY( i, x, z );
                        else uv.setXY( i, y, x );
                    }
                    uv.needsUpdate = true;
                }
            }           
			//function init() {

                /*Scene*/
                {
                const pmremgen = new THREE.PMREMGenerator(new THREE.WebGLRenderer());
                scene = new THREE.Scene();
                scene.background = new THREE.Color().setRGB( 100, 100, 100 );

                renderer = new THREE.WebGLRenderer( {antialias: true} );
                renderer.setSize( innerWidth, innerHeight );
                renderer.setAnimationLoop( animationLoop );
                }

                /*Lights*/
                {
 
                scene.fog = new THREE.Fog( scene.background, 1, 5000 );

                const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 50, 0 );
				scene.add( hemiLight );
				
				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( - 1, 1.75, 1 );
				dirLight.position.multiplyScalar( 30 );
				scene.add( dirLight );

				dirLight.castShadow = true;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;
				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

               

               /* Skybox */
               
				const vertexShader = document.getElementById( 'vertexShader' ).textContent;
				const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				const uniforms = {
					'topColor': { value: new THREE.Color( 0x0077ff ) },
					'bottomColor': { value: new THREE.Color( 0xdeefff ) },
					'offset': { value: 33 },
					'exponent': { value: 0.6 }
				};
				uniforms[ 'topColor' ].value.copy( hemiLight.color );

				scene.fog.color.copy( uniforms[ 'bottomColor' ].value );

				const skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				const skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
				} );

				const sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

               }

               /*Camera*/
                {
                camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 5000 );

                camera.position.y = 5;
                camera.position.z = 10;

                scene.add( camera );
                }

                /*Textures*/
                {
                   

                }

                /*Assets*/
                {

                /*
                const grid = new THREE.GridHelper( 50, 50, 0xffffff, 0x7b7b7b );
                scene.add( grid );
                */

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // Load the texture
                const prototype5x5G = new THREE.TextureLoader().load("https://i.ibb.co/zbcHTcm/prototype5x5.png");

                // Set wrapping and repeating
                prototype5x5G.wrapS = THREE.RepeatWrapping;
                prototype5x5G.wrapT = THREE.RepeatWrapping;
                const pt5gtextureRepeatX = -1; // Width / Length of platRECTgeometry
                const pt5gtextureRepeatY = 1;      // Height remains constant
                prototype5x5G.repeat.set(pt5gtextureRepeatX, pt5gtextureRepeatY);
                prototype5x5G.flipY = true;

                // Define material with the texture
                const platmaterial = new THREE.MeshStandardMaterial({ map: prototype5x5G });

                // Shapes
                const platSQgeometry = new THREE.BoxGeometry(10, 1, 10);
                const platRECTgeometry = new THREE.BoxGeometry(7, 1, 10);
                const platCUBEgeometry = new THREE.BoxGeometry(1, 1, 1);

                // Create the platform
                const plat1 = new THREE.Mesh(platRECTgeometry, platmaterial);
                plat1.position.set(0, 0, 0);
                scene.add(plat1);
                physics.add.existing(plat1)

                const skybxgeometry = new THREE.BoxGeometry(-500, -500, -500 );
                let skybxgradient = new THREE.ShaderMaterial({
                    uniforms: {
                        colors: { 
                        value: [ new THREE.Color('#1396c2'), new THREE.Color('#8ce2fa')]
                        }
                    },
                    vertexShader: `
                        varying float h; 

                        void main() {
                        h = position.y;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 colors[2]; 

                        varying float h;

                        void main() {
                        float f = (h + 100.) / 200.;  // linear interpolation
                                                    // but you can also use 'smoothstep'
                        f = clamp(f, 0., 1.);
                        gl_FragColor = vec4(mix(colors[0], colors[1], f), 1.0);
                        }
                    `
                    })
                    const daskybox = new THREE.Mesh( skybxgeometry, skybxgradient );
                    scene.background = new THREE.Color( 'skyblue' );
                   // scene.add( daskybox );
                    renderer.render( scene, camera );
                    resize(plat1, 1, 1, 1, true);

                }   

                /*Controls*/
                {
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render );
                controls.update();
                }

                /*Events*/
                {
                window.addEventListener( 'resize', onWindowResize );
                }
            

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

            function animationLoop() {


              
                renderer.render( scene, camera );
            }

		</script>
	</body>
</html>