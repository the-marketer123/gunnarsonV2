<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Gunnarson V2 Alpha</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script><!--J Query-->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js'></script><!--GL Matrix-->
        <script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script> <!--Cannon.js-->
        <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }
        
        #board-canvas {
            display: none; 
        }
        a {
            color: #ff0;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        button {
            cursor: pointer;
            text-transform: uppercase;
        }
        
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            z-index: 1; /* TODO Solve this in HTML */
        }
        
        a, button, input, select {
            pointer-events: auto;
        }
        
        .lil-gui {
            z-index: 2 !important; /* TODO Solve this in HTML */
        }
        
        @media all and ( max-width: 640px ) {
            .lil-gui.root { 
                right: auto;
                top: auto;
                max-height: 50%;
                max-width: 80%;
                bottom: 0;
                left: 0;
            }
        }
        
        #overlay {
            position: absolute;
            font-size: 16px;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0,0,0,0.7);
        }
        
            #overlay button {
                background: transparent;
                border: 0;
                border: 1px solid rgb(255, 255, 255);
                border-radius: 4px;
                color: #ffffff;
                padding: 12px 18px;
                text-transform: uppercase;
                cursor: pointer;
            }
        
        #notSupported {
            width: 50%;
            margin: auto;
            background-color: #f00;
            margin-top: 20px;
            padding: 10px;
        }
        </style>
	</head>
	<body>
        <canvas id='board-canvas' width='800' height='1500'></canvas>
		<script type="importmap">
            {
                "imports": {
                  "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.172.0/three.module.js",
                  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
                }
            }
        </script>
   
        <script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>

		<script type="module">

			import * as THREE from 'three';
			import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import  Stats  from 'three/addons/libs/stats.module.js'


			let camera, scene, renderer, plat1, prototype5x5G;


            function resize( object, scaleX, scaleY, scaleZ, updateUV )
            {
                object.scale.set( scaleX, scaleY, scaleZ );
            
                if( updateUV )
                {
                    var pos = object.geometry.getAttribute( 'position' ),
                        uv = object.geometry.getAttribute( 'uv' );

                    for( var i=0; i<pos.count; i++ )
                    {
                        var x = scaleX * (-pos.getX(i)+0.5),
                            y = scaleY * (-pos.getY(i)+0.5),
                            z = scaleZ * (-pos.getZ(i)+0.5);

                        if( i<8 ) uv.setXY( i, z, y );
                        else if( i<16 ) uv.setXY( i, x, z );
                        else uv.setXY( i, y, x );
                    }
                    uv.needsUpdate = true;
                }
            }           
			//function init() {

                /*Scene*/
                
                const pmremgen = new THREE.PMREMGenerator(new THREE.WebGLRenderer());
                scene = new THREE.Scene();
                scene.background = new THREE.Color().setRGB( 100, 100, 100 );

                renderer = new THREE.WebGLRenderer( {antialias: true} );
                renderer.setSize( innerWidth, innerHeight );
                renderer.setAnimationLoop( animationLoop );

                //textures
                let boardCanvas=document.getElementById('board-canvas');
                let board_ctx=boardCanvas.getContext('2d');

                // CANNON.JS World
                const cannonworld = new CANNON.World();
                cannonworld.gravity.set(0, -9.82, 0);

                const stats = new Stats()
                document.body.appendChild(stats.dom)

                const clock = new THREE.Clock()
                let delta
                            
                
                /*Functions*/ 

                let pcubeBodys = [], pcubeShapes = [], cubeMeshes = [];

                function addCubePhysics(object, mass) { // automatically add physics to cubes

                    cubeMeshes.push(object);

                    let newPhysicsShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))
                    let newPhysicsBody = new CANNON.Body({mass: mass})

                    newPhysicsBody.addShape(newPhysicsShape)
                    newPhysicsBody.position.x = object.position.x
                    newPhysicsBody.position.y = object.position.y
                    newPhysicsBody.position.z = object.position.z

                    pcubeShapes.push(newPhysicsShape);
                    pcubeBodys.push(newPhysicsBody);

                    cannonworld.addBody(newPhysicsBody)
                }

                function updateCubePhysics() {
                    let cml = cubeMeshes.length;
                    for (var i = 0; i<cml; i++) {
                        var e = i;
                        cubeMeshes[e].position.set(pcubeBodys[e].position.x, pcubeBodys[e].position.y, pcubeBodys[e].position.z)
                        cubeMeshes[e].quaternion.set(pcubeBodys[e].quaternion.x, pcubeBodys[e].quaternion.y, pcubeBodys[e].quaternion.z, pcubeBodys[e].quaternion.w)
                    }

                }


                /*Lights*/
                
 
                scene.fog = new THREE.Fog( scene.background, 1, 5000 );

                const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 50, 0 );
				scene.add( hemiLight );
				
				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( - 1, 1.75, 1 );
				dirLight.position.multiplyScalar( 30 );
				scene.add( dirLight );

				dirLight.castShadow = true;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;
				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

               

               /* Skybox */
               
				const vertexShader = document.getElementById( 'vertexShader' ).textContent;
				const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				const uniforms = {
					'topColor': { value: new THREE.Color( 0x0077ff ) },
					'bottomColor': { value: new THREE.Color( 0xdeefff ) },
					'offset': { value: 33 },
					'exponent': { value: 0.6 }
				};
				uniforms[ 'topColor' ].value.copy( hemiLight.color );

				scene.fog.color.copy( uniforms[ 'bottomColor' ].value );

				const skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				const skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
				} );

				const sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

               

               /*Camera*/
                
                camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 5000 );

                camera.position.y = 5;
                camera.position.z = 10;

                scene.add( camera );
                

                /*Textures*/
                
                                
                function initTextures() {
                    // Prepare the board canvas
                    board_ctx.fillStyle = 'rgb(0,0,0)';
                    board_ctx.fillRect(0, 0, 512, 512);
                    board_ctx.lineWidth = 3;

                    // Draw the cross lines
                    board_ctx.beginPath();
                    board_ctx.moveTo(256, 0);
                    board_ctx.lineTo(256, 512);
                    board_ctx.closePath();
                    board_ctx.strokeStyle = 'rgb(255,255,255)';
                    board_ctx.stroke();

                    board_ctx.beginPath();
                    board_ctx.moveTo(0, 256);
                    board_ctx.lineTo(512, 256);
                    board_ctx.closePath();
                    board_ctx.strokeStyle = 'rgb(255,255,255)';
                    board_ctx.stroke();

                    // Draw text and borders
                    board_ctx.fillStyle = 'rgb(255,255,255)';
                    board_ctx.font = 'bold 40px arial';
                    board_ctx.fillText('Prototype', 20, 50);
                    board_ctx.fillText('5 x 5 ft.', 20, 100);
                    board_ctx.fillRect(0, 0, 7, 512);
                    board_ctx.fillRect(512, 0, -7, 512);
                    board_ctx.fillRect(0, 0, 512, 7);
                    board_ctx.fillRect(0, 512, 512, -7);

                    // Create the first texture
                    const boxTexture = new THREE.Texture(boardCanvas);
                    boxTexture.needsUpdate = true;

                    // Clear and draw the second texture
                    board_ctx.clearRect(0, 0, 1500, 1500);
                    board_ctx.font = 'bold 30px arial';
                    board_ctx.fillStyle = 'rgb(0,0,0)';
                    board_ctx.fillText('WASD to move', 10, 30);
                    board_ctx.fillText('SPACE to jump', 10, 65);
                    board_ctx.fillText('Shoot the enemy!', 10, 125);
                    board_ctx.fillText('Drop your weapon', 10, 190);
                    board_ctx.fillText('& hold down your', 12, 220);
                    board_ctx.fillText('mouse to move the', 7, 250);
                    board_ctx.fillText('boxes and spheres!', 5, 280);
                    board_ctx.fillText('SHIFT to crouch', 20, 340);
                    board_ctx.fillText('Hold jump while', 20, 400);
                    board_ctx.fillText('touching a wall', 20, 430);
                    board_ctx.fillText('to walljump!', 50, 460);
                    board_ctx.fillText('Use the cube to', 20, 500);
                    board_ctx.fillText('break the glass', 20, 530);
                    board_ctx.fillText('& kill the enemy', 20, 560);
                    board_ctx.fillText('Press E to drop', 20, 605);
                    board_ctx.fillText('your weapon!', 35, 640);
                    board_ctx.fillText('OWO', 90, 700);
                    board_ctx.fillText('whta r u doign hre?', 3, 730);
                    board_ctx.fillText('Congratulations!', 20, 780);
                    board_ctx.fillText('You are now an', 27, 810);
                    board_ctx.fillText('EPIC GAMER!!!!', 27, 845);
                    board_ctx.fillText('Thx 4 playing!!!', 30, 900);
                    board_ctx.fillText('More games to come!', 4, 1012);
                    board_ctx.font = 'bold 20px arial';
                    board_ctx.fillText('The end of a game...', 40, 949);
                    board_ctx.font = 'bold 15px arial';
                    board_ctx.fillText('The beginning of the best games on KA', 10, 969);

                    // Create the second texture
                    const messagesTexture = new THREE.Texture(boardCanvas);
                    messagesTexture.needsUpdate = true;

                    // Define texture bounds
                    const bounds = [
                        [0, 0, 235, 90],
                        [0, 95, 275, 50],
                        [0, 160, 295, 140],
                        [0, 370, 275, 100],
                        [0, 470, 275, 110],
                        [0, 580, 275, 80],
                        [0, 310, 275, 35],
                        [0, 671, 285, 75],
                        [0, 750, 319, 280],
                    ];

                    bounds.forEach(bound => {
                        bound[0] /= 1500;
                        bound[1] /= 1500;
                        bound[2] /= 1500;
                        bound[3] /= 1500;
                    });

                    boxTexture.needsUpdate = true;
                    boxTexture.wrapS = THREE.RepeatWrapping;
                    boxTexture.wrapT = THREE.RepeatWrapping;
 
                    return {
                        boxTexture,
                        messagesTexture,
                        bounds,
                    };
                }

                const textures = initTextures();
                console.log(textures.boxTexture);
                

                /*Assets*/
                

                /*
                const grid = new THREE.GridHelper( 50, 50, 0xffffff, 0x7b7b7b );
                scene.add( grid );
                */

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // Load the texture
                prototype5x5G = new THREE.TextureLoader().load("https://i.ibb.co/zbcHTcm/prototype5x5.png");

                // Set wrapping and repeating
                prototype5x5G.wrapS = THREE.RepeatWrapping;
                prototype5x5G.wrapT = THREE.RepeatWrapping;
                const pt5gtextureRepeatX = -1; // Width / Length of platRECTgeometry
                const pt5gtextureRepeatY = 1;      // Height remains constant
                prototype5x5G.repeat.set(pt5gtextureRepeatX, pt5gtextureRepeatY);
                prototype5x5G.flipY = true;



                // Define material with the texture
                const platmaterial = new THREE.MeshStandardMaterial({ map: textures.boxTexture });

                // Shapes
                const platSQgeometry = new THREE.BoxGeometry(10, 1, 10);
                const platRECTgeometry = new THREE.BoxGeometry(7, 1, 10);
                const platCUBEgeometry = new THREE.BoxGeometry(1, 1, 1);

                //test box
                const normalMaterial = new THREE.MeshStandardMaterial()
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)
                const cubeMesh = new THREE.Mesh(cubeGeometry, normalMaterial)
                cubeMesh.position.x = 0;
                cubeMesh.position.y = 30;
                cubeMesh.castShadow = true;
                scene.add(cubeMesh)
                addCubePhysics(cubeMesh, 1);
 
                // Create the platform
                plat1 = new THREE.Mesh(platRECTgeometry, platmaterial);
                plat1.position.set(0, 0, 0);
                scene.add(plat1);

                const skybxgeometry = new THREE.BoxGeometry(-500, -500, -500 );
                let skybxgradient = new THREE.ShaderMaterial({
                    uniforms: {
                        colors: { 
                        value: [ new THREE.Color('#1396c2'), new THREE.Color('#8ce2fa')]
                        }
                    },
                    vertexShader: `
                        varying float h; 

                        void main() {
                        h = position.y;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 colors[2]; 

                        varying float h;

                        void main() {
                        float f = (h + 100.) / 200.;  // linear interpolation
                                                    // but you can also use 'smoothstep'
                        f = clamp(f, 0., 1.);
                        gl_FragColor = vec4(mix(colors[0], colors[1], f), 1.0);
                        }
                    `
                    })
                    
                const daskybox = new THREE.Mesh( skybxgeometry, skybxgradient );
                scene.background = new THREE.Color( 'skyblue' );
                // scene.add( daskybox );
                resize(plat1, 1, 1, 1, true);

                

                /*Controls*/
                
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render );
                controls.update();
                

                /*Events*/
                
                window.addEventListener( 'resize', onWindowResize );
                
            

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

            function animationLoop() {

                delta = Math.min(clock.getDelta(), 0.1)
                cannonworld.step(delta)

                updateCubePhysics();
                //cubeMesh.position.set(cubeBody.position.x, cubeBody.position.y, cubeBody.position.z)
                //cubeMesh.quaternion.set(cubeBody.quaternion.x, cubeBody.quaternion.y, cubeBody.quaternion.z, cubeBody.quaternion.w)
                
                renderer.render( scene, camera );
                stats.update();
            }

		</script>
	</body>
</html>
